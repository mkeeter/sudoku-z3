(define (sym row col) (string->symbol (format #f "v~A~A" row col)))
(define (bit row col) `(bvshl one ,(sym row col)))
(define (flatten rows cols f)
  (let recurse ((rs rows) (cs cols))
    (cond ((null? cs) '())
          ((null? rs)(recurse rows (cdr cs)))
          (else (cons (f (car rs) (car cs)) (recurse (cdr rs) cs))))))
(define (bitor rows cols)
  `(assert (= full ,(cons 'bvor (flatten rows cols bit)))))
(define (parse-row row s)
  (let recurse ((col 1) (s (string->list s)))
    (if (null? s) '()
      (let ((c (- (char->integer (car s)) (char->integer #\1))))
        (if (and (>= c 0) (<= c 8))
          (format #t "(assert (= ~A #b~9,,,'0@a))\n" (sym row col) (number->string c 2))
          )
        (recurse (+ 1 col) (cdr s))
        ))))
(define (parse-board)
  (apply append
    (map (lambda (row) (parse-row row (symbol->string (read)))) (iota 9 1))))
(define rows (map (lambda (row) (bitor (list row) (iota 9 1))) (iota 9 1)))
(define cols (map (lambda (col) (bitor (iota 9 1) (list col))) (iota 9 1)))
(define squares (flatten '(1 4 7) '(1 4 7)
  (lambda (row col) (bitor (iota 3 row) (iota 3 col)))))
(format #t "
(set-logic QF_BV) 
(set-option :produce-models true)
(declare-const one (_ BitVec 9))
(assert (= one #b000000001))
(declare-const full (_ BitVec 9))
(assert (= full #b111111111))
")
(flatten (iota 9 1) (iota 9 1)
  (lambda (row col)
    (format #t "~A\n" `(declare-const ,(sym row col) (_ BitVec 9)))))
(map (lambda (t) (format #t "~A\n" t)) (append rows cols squares (parse-board)))
(format #t "(check-sat)(get-model)(exit)\n")
